package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
)

var pkg = flag.String("pkg", "libhtml", "Package name to use")
var url = flag.String("url", "https://html.spec.whatwg.org/entities.json", "The HTTP URL to download entities.json from")
var out_file = flag.String("out", "html_entities.go", "Output file")

func main() {
	flag.Parse()

	log.SetPrefix("[html_entities_gen] ")
	log.Printf("Downloading from %s", *url)
	res, err := http.Get(*url)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("Decoding JSON")
	dec := json.NewDecoder(res.Body)
	var entries map[string]map[string]any
	if err := dec.Decode(&entries); err != nil {
		log.Fatal(err)
	}
	log.Println("Reading entries")
	sb := strings.Builder{}
	sb.WriteString(fmt.Sprintf("// Auto-generated by html_entities_gen(using the JSON file from %s)\n// DO NOT EDIT.\n", *url))
	sb.WriteString(fmt.Sprintf("package %s\n\n", *pkg))
	sb.WriteString("var html_entities = map[string]struct{\n    characters string\n    codepoints []int\n}{\n")
	for name, v := range entries {
		sb_line := strings.Builder{}
		characters_, ok := v["characters"]
		if !ok {
			log.Printf("[%s].characters do not exist -- skipping the entry\n", name)
			continue
		}
		characters, ok := characters_.(string)
		if !ok {
			log.Printf("[%s].characters is not string -- skipping the entry\n", name)
			continue
		}

		codepoints_, ok := v["codepoints"]
		if !ok {
			log.Printf("[%s].codepoints do not exist -- skipping the entry\n", name)
			continue
		}
		codepoints, ok := codepoints_.([]any)
		if !ok {
			log.Printf("[%s].codepoints is not array -- skipping the entry\n", name)
			continue
		}

		sb_line.WriteString(fmt.Sprintf("    %s: {characters: %s, codepoints: []int{", strconv.Quote(name), strconv.Quote(characters)))

		first := true
		for i, cp_ := range codepoints {
			cp_f, ok := cp_.(float64)
			if !ok {
				log.Printf("[%s].codepoints[%d] is not number -- skipping the codepoint\n", name, i)
				continue
			}
			cp_i := int(cp_f)
			if !first {
				sb_line.WriteString(", ")
			}
			sb_line.WriteString(fmt.Sprintf("%#x", cp_i))
			first = false
		}
		sb_line.WriteString("}},\n")
		sb.WriteString(sb_line.String())
	}
	sb.WriteString("}\n")

	log.Printf("Formatting generated source")
	unformatted := []byte(sb.String())
	formatted, err := format.Source(unformatted)
	if err != nil {
		log.Println(err)
		log.Println("Formatting error -- Writing unformatted source code instead")
		formatted = unformatted
	}
	log.Printf("Writing output to %s", *out_file)
	err = os.WriteFile(*out_file, formatted, 0644)
	if err != nil {
		log.Fatal(err)
	}
}
