/*
 * This file is part of YW project. Copyright 2025 Oh Inseo (YJK)
 * SPDX-License-Identifier: BSD-3-Clause
 * See LICENSE for details, and LICENSE_WHATWG_SPECS for WHATWG license information.
 */
#include "../yw/yw_common.h"
#include "../yw/yw_json.h"
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

/* Caller owns the returned buffer */
static bool yw_read_file(uint8_t **buf_out, int *len_out, char const *filename)
{
    long len;
    uint8_t *buf = NULL;
    FILE *file = fopen(filename, "r");
    if (file == NULL)
    {
        perror("fopen");
        goto fail;
    }
    if (fseek(file, 0, SEEK_END) < 0)
    {
        perror("fseek");
        goto fail;
    }
    len = ftell(file);
    if (len < 0)
    {
        perror("ftell");
        goto fail;
    }
    if (fseek(file, 0, SEEK_SET) < 0)
    {
        perror("fseek");
        goto fail;
    }
    if (INT_MAX < len)
    {
        fprintf(stderr, "file is too large\n");
        goto fail;
    }
    buf = YW_ALLOC(uint8_t, len);
    if (fread(buf, 1, len, file) != (size_t)len)
    {
        perror("fread");
        goto fail;
    }
    *buf_out = buf;
    *len_out = len;
    return true;
fail:
    free(buf);
    if (file != NULL)
    {
        fclose(file);
    }
    return false;
}

static char *yw_prog_name;

static bool yw_read_and_process_json(FILE *dest, uint8_t const *buf, int len)
{
    bool ok = true;

    fprintf(dest, "/* Auto-generated by html_entities_gen. DO NOT EDIT. */\n");
    fprintf(dest, "struct { char const *name; char const *str; } yw_html_entities[] = {\n");
    YW_JSONValue *root_obj_v = yw_json_parse(buf, len);
    YW_JSONObjectValue const *root_obj = yw_json_expect_object(root_obj_v);
    if (root_obj == NULL)
    {
        goto fail;
    }
    for (int i = 0; i < root_obj->len; i++)
    {
        char *name = yw_json_string_to_c_str(&root_obj->entries[i].name);
        char *characters = NULL;
        YW_JSONValue const *entry_obj_v = root_obj->entries[i].value;
        YW_JSONArrayValue const *codepoints = yw_json_expect_array(yw_json_find_object_entry(entry_obj_v, "codepoints"));
        characters = yw_json_string_to_c_str(yw_json_expect_string(yw_json_find_object_entry(entry_obj_v, "characters")));
        if (codepoints == NULL || characters == NULL)
        {
            goto bad_item;
        }
        fprintf(dest, "    { \"%s\", \"", name);
        for (int i = 0; i < codepoints->len; i++)
        {
            double cp;
            if (!yw_json_expect_number(&cp, codepoints->items[i]))
            {
                fprintf(stderr, "%s: codepoints[%d] in [%s] is not a number. skipping...\n", yw_prog_name, i, name);
                continue;
            }
            if ((int)cp == 0)
            {
                fprintf(stderr, "%s: codepoints[%d] in [%s] is codepoint 0. skipping...\n", yw_prog_name, i, name);
                continue;
            }
            char *temp_str = yw_char_to_str(cp);
            for (int i = 0; temp_str[i] != '\0'; i++)
            {
                fprintf(dest, "\\x%02x", (uint8_t)temp_str[i]);
            }
            free(temp_str);
        }
        fprintf(dest, "\" },\n");
        goto cont;
    bad_item:
        fprintf(stderr, "%s: object entry [%s] has bad format\n", yw_prog_name, name);
    cont:
        free(name);
        free(characters);
    }
    fprintf(dest, "};\n");

    goto out;
fail:
    ok = false;
out:
    yw_json_value_free(root_obj_v);
    return ok;
}

int main(int argc, char **argv)
{
    uint8_t *in_file_buf = NULL;
    int in_file_len = 0;
    FILE *out_file = NULL;
    int exit_code = 0;
    if (argc < 3)
    {
        fprintf(stderr, "Usage: %s <input file> <output file>\n", argv[0]);
        goto fail;
    }
    yw_prog_name = argv[0];
    out_file = fopen(argv[2], "w");
    if (out_file == NULL)
    {
        perror("fopen");
        fprintf(stderr, "%s: failed to open file %s\n", yw_prog_name, argv[2]);
        goto fail;
    }
    if (!yw_read_file(&in_file_buf, &in_file_len, argv[1]))
    {
        fprintf(stderr, "%s: failed to read file %s\n", yw_prog_name, argv[1]);
        goto fail;
    }
    if (!yw_read_and_process_json(out_file, in_file_buf, in_file_len))
    {
        fprintf(stderr, "%s: failed to process json\n", yw_prog_name);
        goto fail;
    }
    goto out;
fail:
    exit_code = 1;
    goto out;
out:
    free(in_file_buf);
    if (out_file != NULL)
    {
        fclose(out_file);
    }
    return exit_code;
}
