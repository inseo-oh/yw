// Auto-generated by css/csssyntax/gen
// DO NOT EDIT.

package csssyntax

import (
	"fmt"
	"github.com/inseo-oh/yw/css/backgrounds"
	"github.com/inseo-oh/yw/css/box"
	"github.com/inseo-oh/yw/css/csscolor"
	"github.com/inseo-oh/yw/css/fonts"
	"github.com/inseo-oh/yw/css/props"
	"github.com/inseo-oh/yw/css/textdecor"
	"github.com/inseo-oh/yw/css/values"
)

func (ts *tokenStream) parseBorderColorShorthand() (res props.BorderColorShorthand, err error) {
	items, err := parseRepeation(ts, 4, "border-color", func(ts *tokenStream) (*csscolor.Color, error) {
		var res csscolor.Color
		res, err := ts.parseColor()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return res, err
	}
	res = props.BorderColorShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parseBorderStyleShorthand() (res props.BorderStyleShorthand, err error) {
	items, err := parseRepeation(ts, 4, "border-style", func(ts *tokenStream) (*backgrounds.LineStyle, error) {
		var res backgrounds.LineStyle
		res, err := ts.parseLineStyle()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return res, err
	}
	res = props.BorderStyleShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parseBorderWidthShorthand() (res props.BorderWidthShorthand, err error) {
	items, err := parseRepeation(ts, 4, "border-width", func(ts *tokenStream) (*values.Length, error) {
		var res values.Length
		res, err := ts.parseLineWidth()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return res, err
	}
	res = props.BorderWidthShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parseBorderTopShorthand() (res props.BorderTopShorthand, err error) {
	res = props.BorderTopShorthand{BorderTopWidth: backgrounds.LineWidthMedium, BorderTopStyle: backgrounds.NoLine, BorderTopColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotBorderTopWidth := false
	gotBorderTopStyle := false
	gotBorderTopColor := false
	gotAny := false
	for {
		valid := false
		if !gotBorderTopWidth {
			ts.skipWhitespaces()
			if v, err := ts.parseLineWidth(); err == nil {
				res.BorderTopWidth = v
				gotBorderTopWidth = true
				valid = true
			}
		}
		if !gotBorderTopStyle {
			ts.skipWhitespaces()
			if v, err := ts.parseLineStyle(); err == nil {
				res.BorderTopStyle = v
				gotBorderTopStyle = true
				valid = true
			}
		}
		if !gotBorderTopColor {
			ts.skipWhitespaces()
			if v, err := ts.parseColor(); err == nil {
				res.BorderTopColor = v
				gotBorderTopColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return res, fmt.Errorf("%s: expected border-top value", ts.errorHeader())
	}
	return res, nil
}

func (ts *tokenStream) parseBorderRightShorthand() (res props.BorderRightShorthand, err error) {
	res = props.BorderRightShorthand{BorderRightWidth: backgrounds.LineWidthMedium, BorderRightStyle: backgrounds.NoLine, BorderRightColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotBorderRightWidth := false
	gotBorderRightStyle := false
	gotBorderRightColor := false
	gotAny := false
	for {
		valid := false
		if !gotBorderRightWidth {
			ts.skipWhitespaces()
			if v, err := ts.parseLineWidth(); err == nil {
				res.BorderRightWidth = v
				gotBorderRightWidth = true
				valid = true
			}
		}
		if !gotBorderRightStyle {
			ts.skipWhitespaces()
			if v, err := ts.parseLineStyle(); err == nil {
				res.BorderRightStyle = v
				gotBorderRightStyle = true
				valid = true
			}
		}
		if !gotBorderRightColor {
			ts.skipWhitespaces()
			if v, err := ts.parseColor(); err == nil {
				res.BorderRightColor = v
				gotBorderRightColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return res, fmt.Errorf("%s: expected border-right value", ts.errorHeader())
	}
	return res, nil
}

func (ts *tokenStream) parseBorderBottomShorthand() (res props.BorderBottomShorthand, err error) {
	res = props.BorderBottomShorthand{BorderBottomWidth: backgrounds.LineWidthMedium, BorderBottomStyle: backgrounds.NoLine, BorderBottomColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotBorderBottomWidth := false
	gotBorderBottomStyle := false
	gotBorderBottomColor := false
	gotAny := false
	for {
		valid := false
		if !gotBorderBottomWidth {
			ts.skipWhitespaces()
			if v, err := ts.parseLineWidth(); err == nil {
				res.BorderBottomWidth = v
				gotBorderBottomWidth = true
				valid = true
			}
		}
		if !gotBorderBottomStyle {
			ts.skipWhitespaces()
			if v, err := ts.parseLineStyle(); err == nil {
				res.BorderBottomStyle = v
				gotBorderBottomStyle = true
				valid = true
			}
		}
		if !gotBorderBottomColor {
			ts.skipWhitespaces()
			if v, err := ts.parseColor(); err == nil {
				res.BorderBottomColor = v
				gotBorderBottomColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return res, fmt.Errorf("%s: expected border-bottom value", ts.errorHeader())
	}
	return res, nil
}

func (ts *tokenStream) parseBorderLeftShorthand() (res props.BorderLeftShorthand, err error) {
	res = props.BorderLeftShorthand{BorderLeftWidth: backgrounds.LineWidthMedium, BorderLeftStyle: backgrounds.NoLine, BorderLeftColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotBorderLeftWidth := false
	gotBorderLeftStyle := false
	gotBorderLeftColor := false
	gotAny := false
	for {
		valid := false
		if !gotBorderLeftWidth {
			ts.skipWhitespaces()
			if v, err := ts.parseLineWidth(); err == nil {
				res.BorderLeftWidth = v
				gotBorderLeftWidth = true
				valid = true
			}
		}
		if !gotBorderLeftStyle {
			ts.skipWhitespaces()
			if v, err := ts.parseLineStyle(); err == nil {
				res.BorderLeftStyle = v
				gotBorderLeftStyle = true
				valid = true
			}
		}
		if !gotBorderLeftColor {
			ts.skipWhitespaces()
			if v, err := ts.parseColor(); err == nil {
				res.BorderLeftColor = v
				gotBorderLeftColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return res, fmt.Errorf("%s: expected border-left value", ts.errorHeader())
	}
	return res, nil
}

func (ts *tokenStream) parseBorderShorthand() (res props.BorderShorthand, err error) {
	res = props.BorderShorthand{BorderWidthShorthand: props.BorderWidthShorthand{Left: backgrounds.LineWidthMedium, Top: backgrounds.LineWidthMedium, Right: backgrounds.LineWidthMedium, Bottom: backgrounds.LineWidthMedium}, BorderStyleShorthand: props.BorderStyleShorthand{Left: backgrounds.NoLine, Top: backgrounds.NoLine, Right: backgrounds.NoLine, Bottom: backgrounds.NoLine}, BorderColorShorthand: props.BorderColorShorthand{Left: csscolor.Color{Type: csscolor.CurrentColor}, Top: csscolor.Color{Type: csscolor.CurrentColor}, Right: csscolor.Color{Type: csscolor.CurrentColor}, Bottom: csscolor.Color{Type: csscolor.CurrentColor}}}
	gotBorderWidthShorthand := false
	gotBorderStyleShorthand := false
	gotBorderColorShorthand := false
	gotAny := false
	for {
		valid := false
		if !gotBorderWidthShorthand {
			ts.skipWhitespaces()
			if v, err := ts.parseLineWidth(); err == nil {
				res.BorderWidthShorthand.Left = v
				res.BorderWidthShorthand.Top = v
				res.BorderWidthShorthand.Right = v
				res.BorderWidthShorthand.Bottom = v
				gotBorderWidthShorthand = true
				valid = true
			}
		}
		if !gotBorderStyleShorthand {
			ts.skipWhitespaces()
			if v, err := ts.parseLineStyle(); err == nil {
				res.BorderStyleShorthand.Left = v
				res.BorderStyleShorthand.Top = v
				res.BorderStyleShorthand.Right = v
				res.BorderStyleShorthand.Bottom = v
				gotBorderStyleShorthand = true
				valid = true
			}
		}
		if !gotBorderColorShorthand {
			ts.skipWhitespaces()
			if v, err := ts.parseColor(); err == nil {
				res.BorderColorShorthand.Left = v
				res.BorderColorShorthand.Top = v
				res.BorderColorShorthand.Right = v
				res.BorderColorShorthand.Bottom = v
				gotBorderColorShorthand = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return res, fmt.Errorf("%s: expected border value", ts.errorHeader())
	}
	return res, nil
}

func (ts *tokenStream) parseMarginShorthand() (res props.MarginShorthand, err error) {
	items, err := parseRepeation(ts, 4, "margin", func(ts *tokenStream) (*box.Margin, error) {
		var res box.Margin
		res, err := ts.parseMargin()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return res, err
	}
	res = props.MarginShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parsePaddingShorthand() (res props.PaddingShorthand, err error) {
	items, err := parseRepeation(ts, 4, "padding", func(ts *tokenStream) (*values.LengthResolvable, error) {
		var res values.LengthResolvable
		res, err := ts.parsePadding()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return res, err
	}
	res = props.PaddingShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parseFontShorthand() (res props.FontShorthand, err error) {
	res = props.FontShorthand{FontFamily: fonts.FamilyList{Families: []fonts.Family{{Type: fonts.SansSerif}}}, FontWeight: fonts.NormalWeight, FontStretch: fonts.NormalStretch, FontStyle: fonts.NormalStyle, FontSize: fonts.MediumSize}
	gotFontFamily := false
	gotFontWeight := false
	gotFontStretch := false
	gotFontStyle := false
	gotFontSize := false
	gotAny := false
	for {
		valid := false
		if !gotFontFamily {
			ts.skipWhitespaces()
			if v, err := ts.parseFontFamily(); err == nil {
				res.FontFamily = v
				gotFontFamily = true
				valid = true
			}
		}
		if !gotFontWeight {
			ts.skipWhitespaces()
			if v, err := ts.parseFontWeight(); err == nil {
				res.FontWeight = v
				gotFontWeight = true
				valid = true
			}
		}
		if !gotFontStretch {
			ts.skipWhitespaces()
			if v, err := ts.parseFontStretch(); err == nil {
				res.FontStretch = v
				gotFontStretch = true
				valid = true
			}
		}
		if !gotFontStyle {
			ts.skipWhitespaces()
			if v, err := ts.parseFontStyle(); err == nil {
				res.FontStyle = v
				gotFontStyle = true
				valid = true
			}
		}
		if !gotFontSize {
			ts.skipWhitespaces()
			if v, err := ts.parseFontSize(); err == nil {
				res.FontSize = v
				gotFontSize = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return res, fmt.Errorf("%s: expected font value", ts.errorHeader())
	}
	return res, nil
}

func (ts *tokenStream) parseTextDecorationShorthand() (res props.TextDecorationShorthand, err error) {
	res = props.TextDecorationShorthand{TextDecorationLine: textdecor.NoLine, TextDecorationStyle: textdecor.Solid, TextDecorationColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotTextDecorationLine := false
	gotTextDecorationStyle := false
	gotTextDecorationColor := false
	gotAny := false
	for {
		valid := false
		if !gotTextDecorationLine {
			ts.skipWhitespaces()
			if v, err := ts.parseTextDecorationLine(); err == nil {
				res.TextDecorationLine = v
				gotTextDecorationLine = true
				valid = true
			}
		}
		if !gotTextDecorationStyle {
			ts.skipWhitespaces()
			if v, err := ts.parseTextDecorationStyle(); err == nil {
				res.TextDecorationStyle = v
				gotTextDecorationStyle = true
				valid = true
			}
		}
		if !gotTextDecorationColor {
			ts.skipWhitespaces()
			if v, err := ts.parseColor(); err == nil {
				res.TextDecorationColor = v
				gotTextDecorationColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return res, fmt.Errorf("%s: expected text-decoration value", ts.errorHeader())
	}
	return res, nil
}

var parseFuncMap = map[string]func(ts *tokenStream) (res props.PropertyValue, err error){
	"color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrAuto()
	},
	"height": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrAuto()
	},
	"min-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrAuto()
	},
	"min-height": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrAuto()
	},
	"max-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrNone()
	},
	"max-height": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrNone()
	},
	"display": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseDisplay()
	},
	"visibility": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseVisibility()
	},
	"background-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-top-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-right-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-bottom-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-left-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderColorShorthand()
	},
	"border-top-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineStyle()
	},
	"border-right-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineStyle()
	},
	"border-bottom-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineStyle()
	},
	"border-left-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineStyle()
	},
	"border-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderStyleShorthand()
	},
	"border-top-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineWidth()
	},
	"border-right-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineWidth()
	},
	"border-bottom-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineWidth()
	},
	"border-left-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineWidth()
	},
	"border-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderWidthShorthand()
	},
	"border-top": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderTopShorthand()
	},
	"border-right": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderRightShorthand()
	},
	"border-bottom": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderBottomShorthand()
	},
	"border-left": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderLeftShorthand()
	},
	"border": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderShorthand()
	},
	"margin-top": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMargin()
	},
	"margin-right": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMargin()
	},
	"margin-bottom": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMargin()
	},
	"margin-left": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMargin()
	},
	"margin": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMarginShorthand()
	},
	"padding-top": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePadding()
	},
	"padding-right": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePadding()
	},
	"padding-bottom": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePadding()
	},
	"padding-left": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePadding()
	},
	"padding": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePaddingShorthand()
	},
	"font-family": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontFamily()
	},
	"font-weight": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontWeight()
	},
	"font-stretch": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontStretch()
	},
	"font-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontStyle()
	},
	"font-size": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontSize()
	},
	"font": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontShorthand()
	},
	"text-transform": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextTransform()
	},
	"text-decoration-line": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextDecorationLine()
	},
	"text-decoration-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextDecorationStyle()
	},
	"text-decoration-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"text-decoration": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextDecorationShorthand()
	},
	"text-underline-position": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextDecorationPosition()
	},
}
