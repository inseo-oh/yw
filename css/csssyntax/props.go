// Auto-generated by css/csssyntax/gen
// DO NOT EDIT.

package csssyntax

import (
	"fmt"
	"github.com/inseo-oh/yw/css/backgrounds"
	"github.com/inseo-oh/yw/css/box"
	"github.com/inseo-oh/yw/css/csscolor"
	"github.com/inseo-oh/yw/css/fonts"
	"github.com/inseo-oh/yw/css/props"
	"github.com/inseo-oh/yw/css/textdecor"
	"github.com/inseo-oh/yw/css/values"
)

func (ts *tokenStream) parseBorderColorShorthand() (props.BorderColorShorthand, error) {
	items, err := parseRepeation(ts, 4, "border-color", func(ts *tokenStream) (*csscolor.Color, error) {
		var res csscolor.Color
		res, err := ts.parseColor()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return props.BorderColorShorthand{}, err
	}
	res := props.BorderColorShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parseBorderStyleShorthand() (props.BorderStyleShorthand, error) {
	items, err := parseRepeation(ts, 4, "border-style", func(ts *tokenStream) (*backgrounds.LineStyle, error) {
		var res backgrounds.LineStyle
		res, err := ts.parseLineStyle()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return props.BorderStyleShorthand{}, err
	}
	res := props.BorderStyleShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parseBorderWidthShorthand() (props.BorderWidthShorthand, error) {
	items, err := parseRepeation(ts, 4, "border-width", func(ts *tokenStream) (*values.Length, error) {
		var res values.Length
		res, err := ts.parseLineWidth()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return props.BorderWidthShorthand{}, err
	}
	res := props.BorderWidthShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parseBorderTopShorthand() (props.BorderTopShorthand, error) {
	out := props.BorderTopShorthand{BorderTopWidth: backgrounds.LineWidthMedium, BorderTopStyle: backgrounds.NoLine, BorderTopColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotBorderTopWidth := false
	gotBorderTopStyle := false
	gotBorderTopColor := false
	gotAny := false
	for {
		valid := false
		if !gotBorderTopWidth {
			ts.skipWhitespaces()
			if res, err := ts.parseLineWidth(); err == nil {
				out.BorderTopWidth = res
				gotBorderTopWidth = true
				valid = true
			}
		}
		if !gotBorderTopStyle {
			ts.skipWhitespaces()
			if res, err := ts.parseLineStyle(); err == nil {
				out.BorderTopStyle = res
				gotBorderTopStyle = true
				valid = true
			}
		}
		if !gotBorderTopColor {
			ts.skipWhitespaces()
			if res, err := ts.parseColor(); err == nil {
				out.BorderTopColor = res
				gotBorderTopColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return out, fmt.Errorf("%s: expected border-top value", ts.errorHeader())
	}
	return out, nil
}

func (ts *tokenStream) parseBorderRightShorthand() (props.BorderRightShorthand, error) {
	out := props.BorderRightShorthand{BorderRightWidth: backgrounds.LineWidthMedium, BorderRightStyle: backgrounds.NoLine, BorderRightColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotBorderRightWidth := false
	gotBorderRightStyle := false
	gotBorderRightColor := false
	gotAny := false
	for {
		valid := false
		if !gotBorderRightWidth {
			ts.skipWhitespaces()
			if res, err := ts.parseLineWidth(); err == nil {
				out.BorderRightWidth = res
				gotBorderRightWidth = true
				valid = true
			}
		}
		if !gotBorderRightStyle {
			ts.skipWhitespaces()
			if res, err := ts.parseLineStyle(); err == nil {
				out.BorderRightStyle = res
				gotBorderRightStyle = true
				valid = true
			}
		}
		if !gotBorderRightColor {
			ts.skipWhitespaces()
			if res, err := ts.parseColor(); err == nil {
				out.BorderRightColor = res
				gotBorderRightColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return out, fmt.Errorf("%s: expected border-right value", ts.errorHeader())
	}
	return out, nil
}

func (ts *tokenStream) parseBorderBottomShorthand() (props.BorderBottomShorthand, error) {
	out := props.BorderBottomShorthand{BorderBottomWidth: backgrounds.LineWidthMedium, BorderBottomStyle: backgrounds.NoLine, BorderBottomColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotBorderBottomWidth := false
	gotBorderBottomStyle := false
	gotBorderBottomColor := false
	gotAny := false
	for {
		valid := false
		if !gotBorderBottomWidth {
			ts.skipWhitespaces()
			if res, err := ts.parseLineWidth(); err == nil {
				out.BorderBottomWidth = res
				gotBorderBottomWidth = true
				valid = true
			}
		}
		if !gotBorderBottomStyle {
			ts.skipWhitespaces()
			if res, err := ts.parseLineStyle(); err == nil {
				out.BorderBottomStyle = res
				gotBorderBottomStyle = true
				valid = true
			}
		}
		if !gotBorderBottomColor {
			ts.skipWhitespaces()
			if res, err := ts.parseColor(); err == nil {
				out.BorderBottomColor = res
				gotBorderBottomColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return out, fmt.Errorf("%s: expected border-bottom value", ts.errorHeader())
	}
	return out, nil
}

func (ts *tokenStream) parseBorderLeftShorthand() (props.BorderLeftShorthand, error) {
	out := props.BorderLeftShorthand{BorderLeftWidth: backgrounds.LineWidthMedium, BorderLeftStyle: backgrounds.NoLine, BorderLeftColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotBorderLeftWidth := false
	gotBorderLeftStyle := false
	gotBorderLeftColor := false
	gotAny := false
	for {
		valid := false
		if !gotBorderLeftWidth {
			ts.skipWhitespaces()
			if res, err := ts.parseLineWidth(); err == nil {
				out.BorderLeftWidth = res
				gotBorderLeftWidth = true
				valid = true
			}
		}
		if !gotBorderLeftStyle {
			ts.skipWhitespaces()
			if res, err := ts.parseLineStyle(); err == nil {
				out.BorderLeftStyle = res
				gotBorderLeftStyle = true
				valid = true
			}
		}
		if !gotBorderLeftColor {
			ts.skipWhitespaces()
			if res, err := ts.parseColor(); err == nil {
				out.BorderLeftColor = res
				gotBorderLeftColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return out, fmt.Errorf("%s: expected border-left value", ts.errorHeader())
	}
	return out, nil
}

func (ts *tokenStream) parseBorderShorthand() (props.BorderShorthand, error) {
	out := props.BorderShorthand{BorderWidthShorthand: props.BorderWidthShorthand{Left: backgrounds.LineWidthMedium, Top: backgrounds.LineWidthMedium, Right: backgrounds.LineWidthMedium, Bottom: backgrounds.LineWidthMedium}, BorderStyleShorthand: props.BorderStyleShorthand{Left: backgrounds.NoLine, Top: backgrounds.NoLine, Right: backgrounds.NoLine, Bottom: backgrounds.NoLine}, BorderColorShorthand: props.BorderColorShorthand{Left: csscolor.Color{Type: csscolor.CurrentColor}, Top: csscolor.Color{Type: csscolor.CurrentColor}, Right: csscolor.Color{Type: csscolor.CurrentColor}, Bottom: csscolor.Color{Type: csscolor.CurrentColor}}}
	gotBorderWidthShorthand := false
	gotBorderStyleShorthand := false
	gotBorderColorShorthand := false
	gotAny := false
	for {
		valid := false
		if !gotBorderWidthShorthand {
			ts.skipWhitespaces()
			if res, err := ts.parseLineWidth(); err == nil {
				out.BorderWidthShorthand.Left = res
				out.BorderWidthShorthand.Top = res
				out.BorderWidthShorthand.Right = res
				out.BorderWidthShorthand.Bottom = res
				gotBorderWidthShorthand = true
				valid = true
			}
		}
		if !gotBorderStyleShorthand {
			ts.skipWhitespaces()
			if res, err := ts.parseLineStyle(); err == nil {
				out.BorderStyleShorthand.Left = res
				out.BorderStyleShorthand.Top = res
				out.BorderStyleShorthand.Right = res
				out.BorderStyleShorthand.Bottom = res
				gotBorderStyleShorthand = true
				valid = true
			}
		}
		if !gotBorderColorShorthand {
			ts.skipWhitespaces()
			if res, err := ts.parseColor(); err == nil {
				out.BorderColorShorthand.Left = res
				out.BorderColorShorthand.Top = res
				out.BorderColorShorthand.Right = res
				out.BorderColorShorthand.Bottom = res
				gotBorderColorShorthand = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return out, fmt.Errorf("%s: expected border value", ts.errorHeader())
	}
	return out, nil
}

func (ts *tokenStream) parseMarginShorthand() (props.MarginShorthand, error) {
	items, err := parseRepeation(ts, 4, "margin", func(ts *tokenStream) (*box.Margin, error) {
		var res box.Margin
		res, err := ts.parseMargin()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return props.MarginShorthand{}, err
	}
	res := props.MarginShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parsePaddingShorthand() (props.PaddingShorthand, error) {
	items, err := parseRepeation(ts, 4, "padding", func(ts *tokenStream) (*values.LengthResolvable, error) {
		var res values.LengthResolvable
		res, err := ts.parsePadding()
		if err != nil {
			return nil, err
		}
		return &res, nil
	})
	if err != nil {
		return props.PaddingShorthand{}, err
	}
	res := props.PaddingShorthand{}
	switch len(items) {
	case 1:
		res.Top = *items[0]
		res.Right = *items[0]
		res.Bottom = *items[0]
		res.Left = *items[0]
	case 2:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[0]
		res.Left = *items[1]
	case 3:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[1]
	case 4:
		res.Top = *items[0]
		res.Right = *items[1]
		res.Bottom = *items[2]
		res.Left = *items[3]
	}
	return res, nil
}

func (ts *tokenStream) parseFontShorthand() (props.FontShorthand, error) {
	out := props.FontShorthand{FontFamily: fonts.FamilyList{Families: []fonts.Family{{Type: fonts.SansSerif}}}, FontWeight: fonts.NormalWeight, FontStretch: fonts.NormalStretch, FontStyle: fonts.NormalStyle, FontSize: fonts.MediumSize}
	gotFontFamily := false
	gotFontWeight := false
	gotFontStretch := false
	gotFontStyle := false
	gotFontSize := false
	gotAny := false
	for {
		valid := false
		if !gotFontFamily {
			ts.skipWhitespaces()
			if res, err := ts.parseFontFamily(); err == nil {
				out.FontFamily = res
				gotFontFamily = true
				valid = true
			}
		}
		if !gotFontWeight {
			ts.skipWhitespaces()
			if res, err := ts.parseFontWeight(); err == nil {
				out.FontWeight = res
				gotFontWeight = true
				valid = true
			}
		}
		if !gotFontStretch {
			ts.skipWhitespaces()
			if res, err := ts.parseFontStretch(); err == nil {
				out.FontStretch = res
				gotFontStretch = true
				valid = true
			}
		}
		if !gotFontStyle {
			ts.skipWhitespaces()
			if res, err := ts.parseFontStyle(); err == nil {
				out.FontStyle = res
				gotFontStyle = true
				valid = true
			}
		}
		if !gotFontSize {
			ts.skipWhitespaces()
			if res, err := ts.parseFontSize(); err == nil {
				out.FontSize = res
				gotFontSize = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return out, fmt.Errorf("%s: expected font value", ts.errorHeader())
	}
	return out, nil
}

func (ts *tokenStream) parseTextDecorationShorthand() (props.TextDecorationShorthand, error) {
	out := props.TextDecorationShorthand{TextDecorationLine: textdecor.NoLine, TextDecorationStyle: textdecor.Solid, TextDecorationColor: csscolor.Color{Type: csscolor.CurrentColor}}
	gotTextDecorationLine := false
	gotTextDecorationStyle := false
	gotTextDecorationColor := false
	gotAny := false
	for {
		valid := false
		if !gotTextDecorationLine {
			ts.skipWhitespaces()
			if res, err := ts.parseTextDecorationLine(); err == nil {
				out.TextDecorationLine = res
				gotTextDecorationLine = true
				valid = true
			}
		}
		if !gotTextDecorationStyle {
			ts.skipWhitespaces()
			if res, err := ts.parseTextDecorationStyle(); err == nil {
				out.TextDecorationStyle = res
				gotTextDecorationStyle = true
				valid = true
			}
		}
		if !gotTextDecorationColor {
			ts.skipWhitespaces()
			if res, err := ts.parseColor(); err == nil {
				out.TextDecorationColor = res
				gotTextDecorationColor = true
				valid = true
			}
		}
		ts.skipWhitespaces()
		if !valid {
			break
		}
		gotAny = true
	}
	if !gotAny {
		return out, fmt.Errorf("%s: expected text-decoration value", ts.errorHeader())
	}
	return out, nil
}

var parseFuncMap = map[string]func(ts *tokenStream) (props.PropertyValue, error){
	"color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrAuto()
	},
	"height": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrAuto()
	},
	"min-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrAuto()
	},
	"min-height": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrAuto()
	},
	"max-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrNone()
	},
	"max-height": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseSizeOrNone()
	},
	"display": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseDisplay()
	},
	"visibility": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseVisibility()
	},
	"background-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-top-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-right-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-bottom-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-left-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"border-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderColorShorthand()
	},
	"border-top-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineStyle()
	},
	"border-right-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineStyle()
	},
	"border-bottom-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineStyle()
	},
	"border-left-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineStyle()
	},
	"border-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderStyleShorthand()
	},
	"border-top-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineWidth()
	},
	"border-right-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineWidth()
	},
	"border-bottom-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineWidth()
	},
	"border-left-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseLineWidth()
	},
	"border-width": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderWidthShorthand()
	},
	"border-top": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderTopShorthand()
	},
	"border-right": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderRightShorthand()
	},
	"border-bottom": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderBottomShorthand()
	},
	"border-left": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderLeftShorthand()
	},
	"border": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseBorderShorthand()
	},
	"margin-top": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMargin()
	},
	"margin-right": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMargin()
	},
	"margin-bottom": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMargin()
	},
	"margin-left": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMargin()
	},
	"margin": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseMarginShorthand()
	},
	"padding-top": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePadding()
	},
	"padding-right": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePadding()
	},
	"padding-bottom": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePadding()
	},
	"padding-left": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePadding()
	},
	"padding": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parsePaddingShorthand()
	},
	"font-family": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontFamily()
	},
	"font-weight": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontWeight()
	},
	"font-stretch": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontStretch()
	},
	"font-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontStyle()
	},
	"font-size": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontSize()
	},
	"font": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseFontShorthand()
	},
	"text-transform": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextTransform()
	},
	"text-decoration-line": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextDecorationLine()
	},
	"text-decoration-style": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextDecorationStyle()
	},
	"text-decoration-color": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseColor()
	},
	"text-decoration": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextDecorationShorthand()
	},
	"text-underline-position": func(ts *tokenStream) (props.PropertyValue, error) {
		return ts.parseTextDecorationPosition()
	},
}
