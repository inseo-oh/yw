package main

import (
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"strconv"
	"strings"

	"github.com/inseo-oh/yw/css/internal/propsdef"
)

var requiredImports = []string{
	"github.com/inseo-oh/yw/css/csscolor",
	"github.com/inseo-oh/yw/css/box",
	"github.com/inseo-oh/yw/css/backgrounds",
	"github.com/inseo-oh/yw/css/values",
	"github.com/inseo-oh/yw/css/fonts",
}

var (
	pkg     = flag.String("pkg", "csssyntax", "Package name to use")
	outFile = flag.String("out", "props.go", "Output file")
)

func main() {
	flag.Parse()

	sb := strings.Builder{}
	log.SetPrefix("[css/csssyntax/gen] ")
	log.Println("Generating source code")
	sb.WriteString( /*      */ "// Auto-generated by css/csssyntax/gen\n// DO NOT EDIT.\n")
	sb.WriteString(fmt.Sprintf("package %s\n", *pkg))
	sb.WriteString( /*      */ "\n")
	sb.WriteString( /*      */ "import (\n")
	sb.WriteString(fmt.Sprintf("\t%s\n", strconv.Quote("github.com/inseo-oh/yw/css/props")))
	for _, imp := range requiredImports {
		sb.WriteString(fmt.Sprintf("\t%s\n", strconv.Quote(imp)))
	}
	sb.WriteString( /*      */ ")\n")
	sb.WriteString( /*      */ "\n")
	// Define shorthand struct and parser functions ----------------------------
	for _, prop := range propsdef.Props {
		sbInner := strings.Builder{}
		switch sh := prop.(type) {
		case propsdef.ShorthandSidesProp:
			sbInner.WriteString( /*      */ "\n")
			sbInner.WriteString(fmt.Sprintf("func (ts *tokenStream) %s() (%s, bool) {\n", sh.ParseMethodName(), sh.TypeName(true)))
			sbInner.WriteString(fmt.Sprintf("\titems, _ := parseRepeation(ts, 4, func(ts *tokenStream) (*%s, error) {\n", sh.PropRight.PropType(false).TypeName))
			sbInner.WriteString(fmt.Sprintf("\t\tvar res %s\n", sh.PropRight.PropType(false).TypeName))
			sbInner.WriteString(fmt.Sprintf("\t\tres, ok := ts.%s()\n", sh.PropTop.PropType(false).ParseMethodName))
			sbInner.WriteString( /*      */ "\t\tif !ok {\n")
			sbInner.WriteString( /*      */ "\t\t\treturn nil, nil\n")
			sbInner.WriteString( /*      */ "\t\t}\n")
			sbInner.WriteString( /*      */ "\t\treturn &res, nil\n")
			sbInner.WriteString( /*      */ "\t})\n")
			sbInner.WriteString( /*      */ "\tif items == nil {\n")
			sbInner.WriteString(fmt.Sprintf("\t\treturn %s{}, false\n", sh.TypeName(true)))
			sbInner.WriteString( /*      */ "\t}\n")
			sbInner.WriteString(fmt.Sprintf("\tres := %s{}\n", sh.TypeName(true)))
			sbInner.WriteString( /*      */ "\tswitch len(items) {\n")
			sbInner.WriteString( /*      */ "\tcase 1:\n")
			sbInner.WriteString( /*      */ "\t\tres.Top = *items[0]\n")
			sbInner.WriteString( /*      */ "\t\tres.Right = *items[0]\n")
			sbInner.WriteString( /*      */ "\t\tres.Bottom = *items[0]\n")
			sbInner.WriteString( /*      */ "\t\tres.Left = *items[0]\n")
			sbInner.WriteString( /*      */ "\tcase 2:\n")
			sbInner.WriteString( /*      */ "\t\tres.Top = *items[0]\n")
			sbInner.WriteString( /*      */ "\t\tres.Right = *items[1]\n")
			sbInner.WriteString( /*      */ "\t\tres.Bottom = *items[0]\n")
			sbInner.WriteString( /*      */ "\t\tres.Left = *items[1]\n")
			sbInner.WriteString( /*      */ "\tcase 3:\n")
			sbInner.WriteString( /*      */ "\t\tres.Top = *items[0]\n")
			sbInner.WriteString( /*      */ "\t\tres.Right = *items[1]\n")
			sbInner.WriteString( /*      */ "\t\tres.Bottom = *items[2]\n")
			sbInner.WriteString( /*      */ "\t\tres.Left = *items[1]\n")
			sbInner.WriteString( /*      */ "\tcase 4:\n")
			sbInner.WriteString( /*      */ "\t\tres.Top = *items[0]\n")
			sbInner.WriteString( /*      */ "\t\tres.Right = *items[1]\n")
			sbInner.WriteString( /*      */ "\t\tres.Bottom = *items[2]\n")
			sbInner.WriteString( /*      */ "\t\tres.Left = *items[3]\n")
			sbInner.WriteString( /*      */ "\t}\n")
			sbInner.WriteString( /*      */ "\treturn res, true\n")
			sbInner.WriteString( /*      */ "}\n")
		case propsdef.ShorthandAnyProp:
			sbInner.WriteString( /*      */ "\n")
			sbInner.WriteString(fmt.Sprintf("func (ts *tokenStream) %s() (%s, bool) {\n", sh.ParseMethodName(), sh.TypeName(true)))
			sbInner.WriteString(fmt.Sprintf("\tout := %s\n", sh.PropInitialValue(true)))
			for _, prop := range sh.Props {
				sbInner.WriteString(fmt.Sprintf("\tgot%s := false\n", propsdef.GoIdentNameOfProp(prop)))
			}
			sbInner.WriteString( /*      */ "\tgotAny := false\n")
			sbInner.WriteString( /*      */ "\tfor {\n")
			sbInner.WriteString( /*      */ "\t\tvalid := false\n")
			for _, prop := range sh.Props {
				sbInner.WriteString(fmt.Sprintf("\t\tif !got%s {\n", propsdef.GoIdentNameOfProp(prop)))
				sbInner.WriteString( /*      */ "\t\t\tts.skipWhitespaces()\n")
				if sides, ok := prop.(propsdef.ShorthandSidesProp); ok {
					sbInner.WriteString(fmt.Sprintf("\t\t\tif res, ok := ts.%s(); ok {\n", sides.PropTop.PropType(false).ParseMethodName))
					sbInner.WriteString(fmt.Sprintf("\t\t\t\tout.%s.Left = res\n", propsdef.GoIdentNameOfProp(prop)))
					sbInner.WriteString(fmt.Sprintf("\t\t\t\tout.%s.Top = res\n", propsdef.GoIdentNameOfProp(prop)))
					sbInner.WriteString(fmt.Sprintf("\t\t\t\tout.%s.Right = res\n", propsdef.GoIdentNameOfProp(prop)))
					sbInner.WriteString(fmt.Sprintf("\t\t\t\tout.%s.Bottom = res\n", propsdef.GoIdentNameOfProp(prop)))
				} else {
					sbInner.WriteString(fmt.Sprintf("\t\t\tif res, ok := ts.%s(); ok {\n", prop.PropType(false).ParseMethodName))
					sbInner.WriteString(fmt.Sprintf("\t\t\t\tout.%s = res\n", propsdef.GoIdentNameOfProp(prop)))
				}
				sbInner.WriteString(fmt.Sprintf("\t\t\t\tgot%s = true\n", propsdef.GoIdentNameOfProp(prop)))
				sbInner.WriteString( /*      */ "\t\t\t\tvalid = true\n")
				sbInner.WriteString( /*      */ "\t\t\t}\n")
				sbInner.WriteString( /*      */ "\t\t}\n")
			}
			sbInner.WriteString( /*      */ "\t\tts.skipWhitespaces()\n")
			sbInner.WriteString( /*      */ "\t\tif !valid {\n")
			sbInner.WriteString( /*      */ "\t\t\tbreak\n")
			sbInner.WriteString( /*      */ "\t\t}\n")
			sbInner.WriteString( /*      */ "\t\tgotAny = true\n")
			sbInner.WriteString( /*      */ "\t}\n")
			sbInner.WriteString( /*      */ "\tif !gotAny {\n")
			sbInner.WriteString( /*      */ "\t\treturn out, false\n")
			sbInner.WriteString( /*      */ "\t}\n")
			sbInner.WriteString( /*      */ "\treturn out, true\n")
			sbInner.WriteString( /*      */ "}\n\n")
		}
		sb.WriteString(sbInner.String())
	}
	// Write parser function map -----------------------------------------------
	sb.WriteString("var parseFuncMap = map[string]func(ts *tokenStream) (props.PropertyValue, bool){\n")
	for _, prop := range propsdef.Props {
		sbInner := strings.Builder{}
		sbInner.WriteString(fmt.Sprintf("\t%s: func(ts *tokenStream) (props.PropertyValue, bool) {\n", strconv.Quote(prop.PropName())))
		sbInner.WriteString(fmt.Sprintf("\t\treturn ts.%s()\n", prop.PropType(false).ParseMethodName))
		sbInner.WriteString( /*      */ "\t},\n")
		sb.WriteString(sbInner.String())
	}
	sb.WriteString("}\n\n")
	log.Printf("Formatting generated source")
	unformatted := []byte(sb.String())
	formatted, err := format.Source(unformatted)
	if err != nil {
		log.Println(err)
		log.Println("Formatting error -- Writing unformatted source code instead")
		formatted = unformatted
	}
	log.Printf("Writing output to %s", *outFile)
	err = os.WriteFile(*outFile, formatted, 0644)
	if err != nil {
		log.Fatal(err)
	}
}
