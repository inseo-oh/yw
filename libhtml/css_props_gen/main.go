package main

import (
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"strconv"
	"strings"
)

type css_type struct {
	type_name    string // Go type name
	parse_method string // Parser method in css_token_stream
}

type css_prop interface {
	get_name() string
	get_type() css_type
	get_initial_value() string
	is_inheritable() bool
}

// A CSS property
type css_prop_simple struct {
	name          string   // Name of the property
	tp            css_type // Type of the property value
	initial_value string   // Initial value (Go expression)
	inheritable   bool     // Can inherit?
}

func (p css_prop_simple) get_name() string          { return p.name }
func (p css_prop_simple) get_type() css_type        { return p.tp }
func (p css_prop_simple) get_initial_value() string { return p.initial_value }
func (p css_prop_simple) is_inheritable() bool      { return p.inheritable }

// Shorthand properties for top, right, bottom, left values.
// These take 1~4 values of the same type, and assigned to top, right, bottom, left accordingly.
// Examples: border-color, padding, margin
type css_prop_shorthand_sides struct {
	name        string   // Name of the property
	prop_top    css_prop // Top property
	prop_right  css_prop // Right property
	prop_bottom css_prop // Bottom property
	prop_left   css_prop // Left property
	inheritable bool     // Can inherit?
}

func (p css_prop_shorthand_sides) get_type_name() string {
	return fmt.Sprintf("css_%s_shorthand", strings.ReplaceAll(p.name, "-", "_"))
}
func (p css_prop_shorthand_sides) get_parse_method_name() string {
	return fmt.Sprintf("parse_%s", p.get_type_name())
}
func (p css_prop_shorthand_sides) get_name() string { return p.name }
func (p css_prop_shorthand_sides) get_type() css_type {
	return css_type{
		type_name:    p.get_type_name(),
		parse_method: p.get_parse_method_name(),
	}
}
func (p css_prop_shorthand_sides) get_initial_value() string {
	return fmt.Sprintf(
		"%s{%s, %s, %s, %s}",
		p.get_type_name(),
		p.prop_top.get_initial_value(),
		p.prop_right.get_initial_value(),
		p.prop_bottom.get_initial_value(),
		p.prop_left.get_initial_value(),
	)
}
func (p css_prop_shorthand_sides) is_inheritable() bool { return p.inheritable }

// Shorthand properties for multiple types of properties
// These simply take any of accepted properties in any other, and fills with default values for absent ones.
// Examples: border, font
type css_prop_shorthand_any struct {
	name        string // Name of the property
	props       []css_prop
	inheritable bool // Can inherit?
}

func (p css_prop_shorthand_any) get_type_name() string {
	return fmt.Sprintf("css_%s_shorthand", strings.ReplaceAll(p.name, "-", "_"))
}
func (p css_prop_shorthand_any) get_parse_method_name() string {
	return fmt.Sprintf("parse_%s", p.get_type_name())
}
func (p css_prop_shorthand_any) get_name() string { return p.name }
func (p css_prop_shorthand_any) get_type() css_type {
	return css_type{
		type_name:    p.get_type_name(),
		parse_method: p.get_parse_method_name(),
	}
}
func (p css_prop_shorthand_any) get_initial_value() string {
	sb := strings.Builder{}
	sb.WriteString(fmt.Sprintf("%s{", p.get_type_name()))
	for i, prop := range p.props {
		if i != 0 {
			sb.WriteString(", ")
		}
		sb.WriteString(prop.get_initial_value())
	}
	sb.WriteString("}")
	return sb.String()
}
func (p css_prop_shorthand_any) is_inheritable() bool { return p.inheritable }

func go_ident_name_of_prop(prop css_prop) string {
	return strings.ReplaceAll(prop.get_name(), "-", "_")
}

var pkg = flag.String("pkg", "libhtml", "Package name to use")
var out_file = flag.String("out", "css_props.go", "Output file")

func main() {
	flag.Parse()

	sb := strings.Builder{}
	log.SetPrefix("[css_props_gen] ")
	log.Println("Generating source code")
	sb.WriteString( /*     */ "// Auto-generated by css_props_gen\n// DO NOT EDIT.\n")
	sb.WriteString(fmt.Sprintf("package %s\n", *pkg))
	sb.WriteString( /*     */ "\n")
	sb.WriteString( /*     */ "import (\n")
	sb.WriteString( /*     */ "\t\"fmt\"\n")
	sb.WriteString( /*     */ "\tcm \"yw/libcommon\"\n")
	sb.WriteString( /*     */ ")\n")
	sb.WriteString( /*     */ "\n")
	// Define shorthand struct and parser functions ----------------------------
	for _, prop := range props {
		sb_inner := strings.Builder{}
		if sh, ok := prop.(css_prop_shorthand_sides); ok {
			sb_inner.WriteString(fmt.Sprintf("type %s struct {\n", sh.get_type_name()))
			sb_inner.WriteString(fmt.Sprintf("\ttop    %s\n", sh.prop_top.get_type().type_name))
			sb_inner.WriteString(fmt.Sprintf("\tright  %s\n", sh.prop_right.get_type().type_name))
			sb_inner.WriteString(fmt.Sprintf("\tbottom %s\n", sh.prop_bottom.get_type().type_name))
			sb_inner.WriteString(fmt.Sprintf("\tleft   %s\n", sh.prop_left.get_type().type_name))
			sb_inner.WriteString( /*      */ "}\n")
			sb_inner.WriteString( /*      */ "\n")
			sb_inner.WriteString(fmt.Sprintf("func (ts *css_token_stream) %s() (%s, bool) {\n", sh.get_parse_method_name(), sh.get_type_name()))
			sb_inner.WriteString(fmt.Sprintf("\titems, _ := css_accept_repetion(ts, 4, func(ts *css_token_stream) (*%s, error) {\n", sh.prop_right.get_type().type_name))
			sb_inner.WriteString(fmt.Sprintf("\t\tvar res %s\n", sh.prop_right.get_type().type_name))
			sb_inner.WriteString(fmt.Sprintf("\t\tres, ok := ts.%s()\n", sh.prop_top.get_type().parse_method))
			sb_inner.WriteString( /*      */ "\t\tif !ok {\n")
			sb_inner.WriteString( /*      */ "\t\t\treturn nil, nil\n")
			sb_inner.WriteString( /*      */ "\t\t}\n")
			sb_inner.WriteString( /*      */ "\t\treturn &res, nil\n")
			sb_inner.WriteString( /*      */ "\t})\n")
			sb_inner.WriteString( /*      */ "\tif items == nil {\n")
			sb_inner.WriteString(fmt.Sprintf("\t\treturn %s{}, false\n", sh.get_type_name()))
			sb_inner.WriteString( /*      */ "\t}\n")
			sb_inner.WriteString(fmt.Sprintf("\tres := %s{}\n", sh.get_type_name()))
			sb_inner.WriteString( /*      */ "\tswitch len(items) {\n")
			sb_inner.WriteString( /*      */ "\tcase 1:\n")
			sb_inner.WriteString( /*      */ "\t\tres.top = *items[0]\n")
			sb_inner.WriteString( /*      */ "\t\tres.right = *items[0]\n")
			sb_inner.WriteString( /*      */ "\t\tres.bottom = *items[0]\n")
			sb_inner.WriteString( /*      */ "\t\tres.left = *items[0]\n")
			sb_inner.WriteString( /*      */ "\tcase 2:\n")
			sb_inner.WriteString( /*      */ "\t\tres.top = *items[0]\n")
			sb_inner.WriteString( /*      */ "\t\tres.right = *items[1]\n")
			sb_inner.WriteString( /*      */ "\t\tres.bottom = *items[0]\n")
			sb_inner.WriteString( /*      */ "\t\tres.left = *items[1]\n")
			sb_inner.WriteString( /*      */ "\tcase 3:\n")
			sb_inner.WriteString( /*      */ "\t\tres.top = *items[0]\n")
			sb_inner.WriteString( /*      */ "\t\tres.right = *items[1]\n")
			sb_inner.WriteString( /*      */ "\t\tres.bottom = *items[2]\n")
			sb_inner.WriteString( /*      */ "\t\tres.left = *items[1]\n")
			sb_inner.WriteString( /*      */ "\tcase 4:\n")
			sb_inner.WriteString( /*      */ "\t\tres.top = *items[0]\n")
			sb_inner.WriteString( /*      */ "\t\tres.right = *items[1]\n")
			sb_inner.WriteString( /*      */ "\t\tres.bottom = *items[2]\n")
			sb_inner.WriteString( /*      */ "\t\tres.left = *items[3]\n")
			sb_inner.WriteString( /*      */ "\t}\n")
			sb_inner.WriteString( /*      */ "\treturn res, true\n")
			sb_inner.WriteString( /*      */ "}\n")
			sb_inner.WriteString(fmt.Sprintf("func (sh %s) String() string {\n", sh.get_type_name()))
			sb_inner.WriteString( /*      */ "\treturn fmt.Sprintf(\"%v %v %v %v\", sh.top, sh.right, sh.bottom, sh.left)\n")
			sb_inner.WriteString( /*      */ "}\n\n")
		}
		if sh, ok := prop.(css_prop_shorthand_any); ok {
			sb_inner.WriteString(fmt.Sprintf("type %s struct {\n", sh.get_type_name()))
			for _, prop := range sh.props {
				sb_inner.WriteString(fmt.Sprintf("\t%s %s\n", go_ident_name_of_prop(prop), prop.get_type().type_name))
			}
			sb_inner.WriteString( /*      */ "}\n")
			sb_inner.WriteString( /*      */ "\n")
			sb_inner.WriteString(fmt.Sprintf("func (ts *css_token_stream) %s() (%s, bool) {\n", sh.get_parse_method_name(), sh.get_type_name()))
			sb_inner.WriteString(fmt.Sprintf("\tout := %s\n", sh.get_initial_value()))
			for _, prop := range sh.props {
				sb_inner.WriteString(fmt.Sprintf("\tgot_%s := false\n", go_ident_name_of_prop(prop)))
			}
			sb_inner.WriteString( /*      */ "\tgot_any := false\n")
			sb_inner.WriteString( /*      */ "\tfor {\n")
			sb_inner.WriteString( /*      */ "\t\tvalid := false\n")
			for _, prop := range sh.props {
				sb_inner.WriteString(fmt.Sprintf("\t\tif !got_%s {\n", go_ident_name_of_prop(prop)))
				sb_inner.WriteString( /*      */ "\t\t\tts.skip_whitespaces()\n")
				sb_inner.WriteString(fmt.Sprintf("\t\t\tif res, ok := ts.%s(); ok {\n", prop.get_type().parse_method))
				sb_inner.WriteString(fmt.Sprintf("\t\t\t\tout.%s = res\n", go_ident_name_of_prop(prop)))
				sb_inner.WriteString(fmt.Sprintf("\t\t\t\tgot_%s = true\n", go_ident_name_of_prop(prop)))
				sb_inner.WriteString( /*      */ "\t\t\t\tvalid = true\n")
				sb_inner.WriteString( /*      */ "\t\t\t}\n")
				sb_inner.WriteString( /*      */ "\t\t}\n")
			}
			sb_inner.WriteString( /*      */ "\t\tts.skip_whitespaces()\n")
			sb_inner.WriteString( /*      */ "\t\tif !valid {\n")
			sb_inner.WriteString( /*      */ "\t\t\tbreak\n")
			sb_inner.WriteString( /*      */ "\t\t}\n")
			sb_inner.WriteString( /*      */ "\t\tgot_any = true\n")
			sb_inner.WriteString( /*      */ "\t}\n")
			sb_inner.WriteString( /*      */ "\tif !got_any {\n")
			sb_inner.WriteString( /*      */ "\t\treturn out, false\n")
			sb_inner.WriteString( /*      */ "\t}\n")
			sb_inner.WriteString( /*      */ "\treturn out, true\n")
			sb_inner.WriteString( /*      */ "}\n\n")
			sb_inner.WriteString(fmt.Sprintf("func (sh %s) String() string {\n", sh.get_type_name()))
			sb_inner.WriteString(fmt.Sprintf("\treturn fmt.Sprintf(\"%s\",\n", strings.TrimSpace(strings.Repeat("%v ", len(sh.props)))))
			for _, prop := range sh.props {
				sb_inner.WriteString(fmt.Sprintf("\t\tsh.%s,\n", go_ident_name_of_prop(prop)))
			}
			sb_inner.WriteString( /*      */ "\t)\n")
			sb_inner.WriteString( /*      */ "}\n\n")
		}
		sb.WriteString(sb_inner.String())
	}
	// Write property map ------------------------------------------------------
	sb.WriteString("var css_property_descriptors_map = map[string]css_property_descriptor{\n")
	for _, prop := range props {
		sb_inner := strings.Builder{}
		sb_inner.WriteString(fmt.Sprintf("\t%s: {\n", strconv.Quote(prop.get_name())))
		sb_inner.WriteString(fmt.Sprintf("\t\tinitial: %s,\n", prop.get_initial_value()))
		sb_inner.WriteString( /*      */ "\t\tapply_func: func(dest *css_computed_style_set, value any) {\n")
		sb_inner.WriteString(fmt.Sprintf("\t\t\tv := value.(%s)\n", prop.get_type().type_name))
		sb_inner.WriteString(fmt.Sprintf("\t\t\tdest.%s = &v\n", go_ident_name_of_prop(prop)))
		sb_inner.WriteString( /*      */ "\t\t},\n")
		sb_inner.WriteString( /*      */ "\t\tparse_func: func(ts *css_token_stream) (css_property_value, bool) {\n")
		sb_inner.WriteString(fmt.Sprintf("\t\t\treturn ts.%s()\n", prop.get_type().parse_method))
		sb_inner.WriteString( /*      */ "\t\t},\n")
		sb_inner.WriteString( /*      */ "\t},\n")
		sb.WriteString(sb_inner.String())
	}
	sb.WriteString("}\n\n")
	// Write css_computed_style_set struct -------------------------------------
	sb.WriteString("type css_computed_style_set struct {\n")
	for _, prop := range props {
		sb_inner := strings.Builder{}
		sb_inner.WriteString(fmt.Sprintf("\t%s *%s\n", go_ident_name_of_prop(prop), prop.get_type().type_name))
		sb.WriteString(sb_inner.String())
	}
	sb.WriteString("}\n")
	sb.WriteString("\n")
	// Write css_computed_style_set methods ------------------------------------
	for _, prop := range props {
		sb_inner := strings.Builder{}
		sb_inner.WriteString(fmt.Sprintf("func (css *css_computed_style_set) get_%s() %s {\n", go_ident_name_of_prop(prop), prop.get_type().type_name))
		sb_inner.WriteString(fmt.Sprintf("\tif css.%s == nil {\n", go_ident_name_of_prop(prop)))
		sb_inner.WriteString(fmt.Sprintf("\t\tinitial := css_property_descriptors_map[%s].initial.(%s)\n", strconv.Quote(prop.get_name()), prop.get_type().type_name))
		sb_inner.WriteString(fmt.Sprintf("\t\tcss.%s = &initial\n", go_ident_name_of_prop(prop)))
		sb_inner.WriteString( /*      */ "\t}\n")
		sb_inner.WriteString( /*      */ fmt.Sprintf("\treturn *css.%s\n", go_ident_name_of_prop(prop)))
		sb_inner.WriteString( /*      */ "}\n")
		if prop.is_inheritable() {
			sb_inner.WriteString(fmt.Sprintf("func (css *css_computed_style_set) inherit_%s_from_parent(parent dom_Element) {\n", go_ident_name_of_prop(prop)))
			sb_inner.WriteString( /*      */ "\tparent_css := parent.get_computed_style_set()\n")
			sb_inner.WriteString(fmt.Sprintf("\tif !cm.IsNil(parent_css.%s) {\n", go_ident_name_of_prop(prop)))
			sb_inner.WriteString(fmt.Sprintf("\t\tcss.%s = parent_css.%s\n", go_ident_name_of_prop(prop), go_ident_name_of_prop(prop)))
			sb_inner.WriteString( /*      */ "\t} else if parent_parent := parent.get_parent(); !cm.IsNil(parent_parent) {\n")
			sb_inner.WriteString( /*      */ "\t\tif elem, ok := parent_parent.(dom_Element); ok {\n")
			sb_inner.WriteString(fmt.Sprintf("\t\t\tcss.inherit_%s_from_parent(elem)\n", go_ident_name_of_prop(prop)))
			sb_inner.WriteString( /*      */ "\t\t}\n")
			sb_inner.WriteString( /*      */ "\t}\n")
			sb_inner.WriteString( /*      */ "}\n")
		}
		sb.WriteString(sb_inner.String())
	}
	sb.WriteString( /*      */ "func (css *css_computed_style_set) inherit_properties_from_parent(parent dom_Element) {\n")
	for _, prop := range props {
		sb_inner := strings.Builder{}
		if prop.is_inheritable() {
			sb_inner.WriteString(fmt.Sprintf("css.inherit_%s_from_parent(parent)\n", go_ident_name_of_prop(prop)))
		}
		sb.WriteString(sb_inner.String())
	}
	sb.WriteString( /*      */ "}\n")
	log.Printf("Formatting generated source")
	unformatted := []byte(sb.String())
	formatted, err := format.Source(unformatted)
	if err != nil {
		log.Println(err)
		log.Println("Formatting error -- Writing unformatted source code instead")
		formatted = unformatted
	}
	log.Printf("Writing output to %s", *out_file)
	err = os.WriteFile(*out_file, formatted, 0644)
	if err != nil {
		log.Fatal(err)
	}
}
